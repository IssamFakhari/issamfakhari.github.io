---
published: true
title: Parte1
date: 2021-07-02
layout: single
author_profile: false
read_time: true
tags: [Statistics , Parte1] 
categories: [statistics]
excerpt: " statistics, Parte1"
comments : true
toc: true
toc_sticky: true
---





<iframe
  frameborder="0"
  style="
    border: 1px solid #cfcfcf;
    width: 100%;
    height: 632px;
    "
  srcDoc="
  <!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <title>None</title>
  <meta name=&quot;description&quot; content=&quot;None&quot;>
  <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
  <meta charset=&quot;UTF-8&quot;>
  <!-- Include CARTO VL JS -->
  <script src=&quot;https://libs.cartocdn.com/carto-vl/v1.4/carto-vl.min.js&quot;></script>
  <!-- Include Mapbox GL JS -->
  <script src=&quot;https://api.tiles.mapbox.com/mapbox-gl-js/v1.0.0/mapbox-gl.js&quot;></script>
  <!-- Include Mapbox GL CSS -->
  <link href=&quot;https://api.tiles.mapbox.com/mapbox-gl-js/v1.0.0/mapbox-gl.css&quot; rel=&quot;stylesheet&quot; />

  <!-- Include Airship -->
  <script nomodule=&quot;&quot; src=&quot;https://libs.cartocdn.com/airship-components/v2.3/airship.js&quot;></script>
  <script type=&quot;module&quot; src=&quot;https://libs.cartocdn.com/airship-components/v2.3/airship/airship.esm.js&quot;></script>
  <script src=&quot;https://libs.cartocdn.com/airship-bridge/v2.3/asbridge.min.js&quot;></script>
  <link href=&quot;https://libs.cartocdn.com/airship-style/v2.3/airship.min.css&quot; rel=&quot;stylesheet&quot;>
  <link href=&quot;https://libs.cartocdn.com/airship-icons/v2.3/icons.css&quot; rel=&quot;stylesheet&quot;>

  <link href=&quot;https://fonts.googleapis.com/css?family=Roboto&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;>

  <!-- External libraries -->

  <!-- pako -->
  <script src=&quot;https://libs.cartocdn.com/cartoframes/dependencies/pako_inflate.min.js&quot;></script>

  <!-- html2canvas -->



  <style>
  body {
    margin: 0;
    padding: 0;
  }

  aside.as-sidebar {
    min-width: 300px;
  }

  .map-image {
    display: none;
    max-width: 100%;
    height: auto;
  }

  as-layer-selector-slot .as-layer-selector-slot--wrapper .as-caption { // FIXME
    font-size: 14px;
    line-height: 14px;
  }
</style>
  <style>
  .map {
    position: absolute;
    height: 100%;
    width: 100%;
  }

  .map-info {
    position: absolute;
    bottom: 0;
    padding: 0 5px;
    background-color: rgba(255, 255, 255, 0.5);
    margin: 0;
    color: rgba(0, 0, 0, 0.75);
    font-size: 12px;
    width: auto;
    height: 18px;
    font-family: 'Open Sans';
  }

  .map-footer {
    background: #F2F6F9;
    font-family: Roboto;
    font-size: 12px;
    line-height: 24px;
    color: #162945;
    text-align: center;
    z-index: 2;
  }

  .map-footer a {
    text-decoration: none;
  }

  .map-footer a:hover {
    text-decoration: underline;
  }
</style>
    <style>
    #error-container {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: white;
      visibility: hidden;
      padding: 1em;
      font-family: &quot;Courier New&quot;, Courier, monospace;
      margin: 0 auto;
      font-size: 14px;
      overflow: auto;
      z-index: 1000;
      color: black;
    }

    .error-section {
      padding: 1em;
      border-radius: 5px;
      background-color: #fee;
    }

    #error-container #error-highlight {
      font-weight: bold;
      color: inherit;
    }

    #error-container #error-type {
      color: #008000;
    }

    #error-container #error-name {
      color: #ba2121;
    }

    #error-container #error-content {
      margin-top: 0.4em;
    }

    .error-details {
      margin-top: 1em;
    }

    #error-stacktrace {
      list-style: none;
    }
</style>
  <style>
    .popup-content {
      display: flex;
      flex-direction: column;
      padding: 8px;
    }

    .popup-name {
      font-size: 12px;
      font-weight: 400;
      line-height: 20px;
      margin-bottom: 4px;
    }

    .popup-value {
      font-size: 16px;
      font-weight: 600;
      line-height: 20px;
    }

    .popup-value:not(:last-of-type) {
      margin-bottom: 16px;
    }
</style>
  <style>
  as-widget-header .as-widget-header__header {
    margin-bottom: 8px;
    overflow-wrap: break-word;
  }

  as-widget-header .as-widget-header__subheader {
    margin-bottom: 12px;
  }

  as-category-widget {
    max-height: 250px;
  }
</style>
</head>

<body class=&quot;as-app-body as-app&quot;>
  <img id=&quot;map-image&quot; class=&quot;map-image&quot; alt='Static map image' />
  <as-responsive-content id=&quot;main-container&quot;>

    <main class=&quot;as-main&quot;>
      <div class=&quot;as-map-area&quot;>
        <div id=&quot;map&quot; class=&quot;map&quot;></div>


          <div class=&quot;as-map-panels&quot; data-name=&quot;Legends&quot;>
            <div class=&quot;as-panel as-panel--vertical as-panel--left as-panel--top&quot;>


<div class=&quot;as-panel__element&quot; id=&quot;legends&quot;>
  <as-layer-selector id=&quot;layer-selector&quot;>




        <div slot=&quot;as-checkbox-layer-0-slot&quot;>


              <as-legend
                heading=&quot;price&quot;
                description=&quot;&quot;>
                <as-legend-color-bins id=&quot;layer0_map0_legend0&quot; slot=&quot;legends&quot;></as-legend-color-bins>

              </as-legend>


        </div>


  </as-layer-selector>
</div>
            </div> <!-- as-panel -->
          </div> <!-- as-map-panels -->

      </div> <!-- as-map-area -->
    </main> <!-- as-main -->
  </as-responsive-content>



  <div id=&quot;error-container&quot; class=&quot;error&quot;>
  <section class=&quot;error-section&quot;>
    <span class=&quot;errors&quot; id=&quot;error-name&quot;></span>:
    <section id=&quot;error-content&quot;>
      <span class=&quot;errors&quot; id=&quot;error-type&quot;></span>
      <span class=&quot;errors&quot; id=&quot;error-message&quot;></span>
    </section>
  </section>

  <details class=&quot;error-details&quot;>
    <summary>StackTrace</summary>
    <ul id=&quot;error-stacktrace&quot;></ul>
  </details>
</div>
</body>

<script>
  var init = (function () {
  'use strict';

  const BASEMAPS = {
    DarkMatter: carto.basemaps.darkmatter,
    Voyager: carto.basemaps.voyager,
    Positron: carto.basemaps.positron
  };

  const attributionControl = new mapboxgl.AttributionControl({
    compact: false
  });

  const FIT_BOUNDS_SETTINGS = { animate: false, padding: 50, maxZoom: 16 };

  /** From https://github.com/errwischt/stacktrace-parser/blob/master/src/stack-trace-parser.js */

  /**
   * This parses the different stack traces and puts them into one format
   * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
   */

  const UNKNOWN_FUNCTION = '<unknown>';
  const chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  const chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  const winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  const geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  const geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

  function parse(stackString) {
    const lines = stackString.split('\n');

    return lines.reduce((stack, line) => {
      const parseResult =
        parseChrome(line) ||
        parseWinjs(line) ||
        parseGecko(line);

      if (parseResult) {
        stack.push(parseResult);
      }

      return stack;
    }, []);
  }

  function parseChrome(line) {
    const parts = chromeRe.exec(line);

    if (!parts) {
      return null;
    }

    const isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

    const submatch = chromeEvalRe.exec(parts[2]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line/column number
      parts[2] = submatch[1]; // url
      parts[3] = submatch[2]; // line
      parts[4] = submatch[3]; // column
    }

    return {
      file: !isNative ? parts[2] : null,
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: isNative ? [parts[2]] : [],
      lineNumber: parts[3] ? +parts[3] : null,
      column: parts[4] ? +parts[4] : null,
    };
  }

  function parseWinjs(line) {
    const parts = winjsRe.exec(line);

    if (!parts) {
      return null;
    }

    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null,
    };
  }

  function parseGecko(line) {
    const parts = geckoRe.exec(line);

    if (!parts) {
      return null;
    }

    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;

    const submatch = geckoEvalRe.exec(parts[3]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line number
      parts[3] = submatch[1];
      parts[4] = submatch[2];
      parts[5] = null; // no column when eval
    }

    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: parts[2] ? parts[2].split(',') : [],
      lineNumber: parts[4] ? +parts[4] : null,
      column: parts[5] ? +parts[5] : null,
    };
  }

  function displayError(e) {
    const error$ = document.getElementById('error-container');
    const errors$ = error$.getElementsByClassName('errors');
    const stacktrace$ = document.getElementById('error-stacktrace');

    errors$[0].innerHTML = e.name;
    errors$[1].innerHTML = e.type;
    errors$[2].innerHTML = e.message.replace(e.type, '');

    error$.style.visibility = 'visible';

    const stack = parse(e.stack);
    const list = stack.map(item => {
      return `<li>
      at <span class=&quot;stacktrace-method&quot;>${item.methodName}:</span>
      (${item.file}:${item.lineNumber}:${item.column})
    </li>`;
    });

    stacktrace$.innerHTML = list.join('\n');
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns [&quot;123&quot;, 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(&quot;e&quot;)) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error(&quot;invalid format: &quot; + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? &quot; &quot; : specifier.fill + &quot;&quot;;
    this.align = specifier.align === undefined ? &quot;>&quot; : specifier.align + &quot;&quot;;
    this.sign = specifier.sign === undefined ? &quot;-&quot; : specifier.sign + &quot;&quot;;
    this.symbol = specifier.symbol === undefined ? &quot;&quot; : specifier.symbol + &quot;&quot;;
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? &quot;&quot; : specifier.type + &quot;&quot;;
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? &quot;0&quot; : &quot;&quot;)
        + (this.width === undefined ? &quot;&quot; : Math.max(1, this.width | 0))
        + (this.comma ? &quot;,&quot; : &quot;&quot;)
        + (this.precision === undefined ? &quot;&quot; : &quot;.&quot; + Math.max(0, this.precision | 0))
        + (this.trim ? &quot;~&quot; : &quot;&quot;)
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case &quot;.&quot;: i0 = i1 = i; break;
        case &quot;0&quot;: if (i0 === 0) i0 = i; i1 = i; break;
        default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + &quot;&quot;;
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join(&quot;0&quot;)
        : i > 0 ? coefficient.slice(0, i) + &quot;.&quot; + coefficient.slice(i)
        : &quot;0.&quot; + new Array(1 - i).join(&quot;0&quot;) + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + &quot;&quot;;
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? &quot;0.&quot; + new Array(-exponent).join(&quot;0&quot;) + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + &quot;.&quot; + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join(&quot;0&quot;);
  }

  var formatTypes = {
    &quot;%&quot;: function(x, p) { return (x * 100).toFixed(p); },
    &quot;b&quot;: function(x) { return Math.round(x).toString(2); },
    &quot;c&quot;: function(x) { return x + &quot;&quot;; },
    &quot;d&quot;: function(x) { return Math.round(x).toString(10); },
    &quot;e&quot;: function(x, p) { return x.toExponential(p); },
    &quot;f&quot;: function(x, p) { return x.toFixed(p); },
    &quot;g&quot;: function(x, p) { return x.toPrecision(p); },
    &quot;o&quot;: function(x) { return Math.round(x).toString(8); },
    &quot;p&quot;: function(x, p) { return formatRounded(x * 100, p); },
    &quot;r&quot;: formatRounded,
    &quot;s&quot;: formatPrefixAuto,
    &quot;X&quot;: function(x) { return Math.round(x).toString(16).toUpperCase(); },
    &quot;x&quot;: function(x) { return Math.round(x).toString(16); }
  };

  function identity(x) {
    return x;
  }

  var map = Array.prototype.map,
      prefixes = [&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;µ&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];

  function formatLocale(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + &quot;&quot;),
        currencyPrefix = locale.currency === undefined ? &quot;&quot; : locale.currency[0] + &quot;&quot;,
        currencySuffix = locale.currency === undefined ? &quot;&quot; : locale.currency[1] + &quot;&quot;,
        decimal = locale.decimal === undefined ? &quot;.&quot; : locale.decimal + &quot;&quot;,
        numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
        percent = locale.percent === undefined ? &quot;%&quot; : locale.percent + &quot;&quot;,
        minus = locale.minus === undefined ? &quot;-&quot; : locale.minus + &quot;&quot;,
        nan = locale.nan === undefined ? &quot;NaN&quot; : locale.nan + &quot;&quot;;

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The &quot;n&quot; type is an alias for &quot;,g&quot;.
      if (type === &quot;n&quot;) comma = true, type = &quot;g&quot;;

      // The &quot;&quot; type, and any invalid type, is an alias for &quot;.12~g&quot;.
      else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = &quot;g&quot;;

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === &quot;0&quot; && align === &quot;=&quot;)) zero = true, fill = &quot;0&quot;, align = &quot;=&quot;;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === &quot;$&quot; ? currencyPrefix : symbol === &quot;#&quot; && /[boxX]/.test(type) ? &quot;0&quot; + type.toLowerCase() : &quot;&quot;,
          suffix = symbol === &quot;$&quot; ? currencySuffix : /[%p]/.test(type) ? percent : &quot;&quot;;

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision === undefined ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === &quot;c&quot;) {
          valueSuffix = formatType(value) + valueSuffix;
          value = &quot;&quot;;
        } else {
          value = +value;

          // Determine the sign. -0 is not less than 0, but 1 / -0 is!
          var valueNegative = value < 0 || 1 / value < 0;

          // Perform the initial formatting.
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim(value);

          // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
          if (valueNegative && +value === 0 && sign !== &quot;+&quot;) valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === &quot;(&quot; ? sign : minus) : sign === &quot;-&quot; || sign === &quot;(&quot; ? &quot;&quot; : sign) + valuePrefix;
          valueSuffix = (type === &quot;s&quot; ? prefixes[8 + prefixExponent / 3] : &quot;&quot;) + valueSuffix + (valueNegative && sign === &quot;(&quot; ? &quot;)&quot; : &quot;&quot;);

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not &quot;0&quot;, grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : &quot;&quot;;

        // If the fill character is &quot;0&quot;, grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = &quot;&quot;;

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case &quot;<&quot;: value = valuePrefix + value + valueSuffix + padding; break;
          case &quot;=&quot;: value = valuePrefix + padding + value + valueSuffix; break;
          case &quot;^&quot;: value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + &quot;&quot;;
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = &quot;f&quot;, specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  var format;
  var formatPrefix;

  defaultLocale({
    decimal: &quot;.&quot;,
    thousands: &quot;,&quot;,
    grouping: [3],
    currency: [&quot;$&quot;, &quot;&quot;],
    minus: &quot;-&quot;
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  function formatter(value, specifier) {
    const formatFunc = specifier ? format(specifier) : formatValue;

    if (Array.isArray(value)) {
      const [first, second] = value;
      if (first === -Infinity) {
        return `< ${formatFunc(second)}`;
      }
      if (second === Infinity) {
        return `> ${formatFunc(first)}`;
      }
      return `${formatFunc(first)} - ${formatFunc(second)}`;
    }
    return formatFunc(value);
  }

  function formatValue(value) {
    if (typeof value === 'number') {
      return formatNumber(value);
    }
    return value;
  }

  function formatNumber(value) {
    if (!Number.isInteger(value)) {
      return value.toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 3
      });
    }
    return value.toLocaleString();
  }

  function updateViewport(id, map) {
    function updateMapInfo() {
      const mapInfo$ = document.getElementById(id);
      const center = map.getCenter();
      const lat = center.lat.toFixed(6);
      const lng = center.lng.toFixed(6);
      const zoom = map.getZoom().toFixed(2);

      mapInfo$.innerText = `viewport={'zoom': ${zoom}, 'lat': ${lat}, 'lng': ${lng}}`;
    }

    updateMapInfo();

    map.on('zoom', updateMapInfo);
    map.on('move', updateMapInfo);
  }

  function getBasecolorSettings(basecolor) {
    return {
      'version': 8,
      'sources': {},
      'layers': [{
          'id': 'background',
          'type': 'background',
          'paint': {
              'background-color': basecolor
          }
      }]
    };
  }

  function getImageElement(mapIndex) {
    const id = mapIndex !== undefined ? `map-image-${mapIndex}` : 'map-image';
    return document.getElementById(id);
  }

  function getContainerElement(mapIndex) {
    const id = mapIndex !== undefined ? `main-container-${mapIndex}` : 'main-container';
    return document.getElementById(id);
  }

  function saveImage(mapIndex) {
    const img = getImageElement(mapIndex);
    const container = getContainerElement(mapIndex);

    html2canvas(container)
      .then((canvas) => setMapImage(canvas, img, container));
  }

  function setMapImage(canvas, img, container) {
    const src = canvas.toDataURL();
    img.setAttribute('src', src);
    img.style.display = 'block';
    container.style.display = 'none';
  }

  function resetPopupClick(interactivity) {
    interactivity.off('featureClick');
  }

  function resetPopupHover(interactivity) {
    interactivity.off('featureHover');
  }

  function setPopupsClick(map, clickPopup, hoverPopup, interactivity, attrs) {
    interactivity.on('featureClick', (event) => {
      updatePopup(map, clickPopup, event, attrs);
      hoverPopup.remove();
    });
  }

  function setPopupsHover(map, hoverPopup, interactivity, attrs) {
    interactivity.on('featureHover', (event) => {
      updatePopup(map, hoverPopup, event, attrs);
    });
  }

  function updatePopup(map, popup, event, attrs) {
    if (event.features.length > 0) {
      let popupHTML = '';
      const layerIDs = [];

      for (const feature of event.features) {
        if (layerIDs.includes(feature.layerId)) {
          continue;
        }
        // Track layers to add only one feature per layer
        layerIDs.push(feature.layerId);

        for (const item of attrs) {
          const variable = feature.variables[item.name];
          if (variable) {
            let value = variable.value;
            value = formatter(value, item.format);

            popupHTML = `
            <span class=&quot;popup-name&quot;>${item.title}</span>
            <span class=&quot;popup-value&quot;>${value}</span>
          ` + popupHTML;
          }
        }
      }

      if (popupHTML) {
        popup
            .setLngLat([event.coordinates.lng, event.coordinates.lat])
            .setHTML(`<div class=&quot;popup-content&quot;>${popupHTML}</div>`);

        if (!popup.isOpen()) {
          popup.addTo(map);
        }
      } else {
        popup.remove();
      }
    } else {
      popup.remove();
    }
  }

  function setInteractivity(map, interactiveLayers, interactiveMapLayers) {
    const interactivity = new carto.Interactivity(interactiveMapLayers);

    const clickPopup = new mapboxgl.Popup({
      closeButton: true,
      closeOnClick: false
    });

    const hoverPopup = new mapboxgl.Popup({
      closeButton: false,
      closeOnClick: false
    });

    const { clickAttrs, hoverAttrs } = _setInteractivityAttrs(interactiveLayers);

    resetPopupClick(map);
    resetPopupHover(map);

    if (clickAttrs.length > 0) {
      setPopupsClick(map, clickPopup, hoverPopup, interactivity, clickAttrs);
    }

    if (hoverAttrs.length > 0) {
      setPopupsHover(map, hoverPopup, interactivity, hoverAttrs);
    }
  }

  function _setInteractivityAttrs(interactiveLayers) {
    let clickAttrs = [];
    let hoverAttrs = [];

    interactiveLayers.forEach((interactiveLayer) => {
      interactiveLayer.interactivity.forEach((interactivityDef) => {
        if (interactivityDef.event === 'click') {
          clickAttrs = clickAttrs.concat(interactivityDef.attrs);
        } else if (interactivityDef.event === 'hover') {
          hoverAttrs = hoverAttrs.concat(interactivityDef.attrs);
        }
      });
    });

    return { clickAttrs, hoverAttrs };
  }

  function renderWidget(widget, value) {
    widget.element = widget.element || document.querySelector(`#${widget.id}-value`);

    if (value && widget.element) {
      widget.element.innerText = typeof value === 'number' ? formatter(value, widget.options.format) : value;
    }
  }

  function renderBridge(bridge, widget, mapLayer) {
    widget.element = widget.element || document.querySelector(`#${widget.id}`);

    switch (widget.type) {
      case 'histogram':
        const type = _getWidgetType(mapLayer, widget.value, widget.prop);
        const histogram = type === 'category' ? 'categoricalHistogram' : 'numericalHistogram';
        bridge[histogram](widget.element, widget.value, widget.options);
        break;
      case 'category':
        bridge.category(widget.element, widget.value, widget.options);
        break;
      case 'animation':
        widget.options.propertyName = widget.prop;
        bridge.animationControls(widget.element, widget.value, widget.options);
        break;
      case 'time-series':
        widget.options.propertyName = widget.prop;
        bridge.timeSeries(widget.element, widget.value, widget.options);
        break;
    }
  }

  function bridgeLayerWidgets(map, mapLayer, mapSource, widgets) {
    const bridge = new AsBridge.VL.Bridge({
      carto: carto,
      layer: mapLayer,
      source: mapSource,
      map: map
    });

    widgets
      .filter((widget) => widget.has_bridge)
      .forEach((widget) => renderBridge(bridge, widget, mapLayer));

    bridge.build();
  }

  function _getWidgetType(layer, property, value) {
    return layer.metadata && layer.metadata.properties[value] ?
      layer.metadata.properties[value].type
      : _getWidgetPropertyType(layer, property);
  }

  function _getWidgetPropertyType(layer, property) {
    return layer.metadata && layer.metadata.properties[property] ?
      layer.metadata.properties[property].type
      : null;
  }

  function createLegends(layer, legends, layerIndex, mapIndex=0) {
    if (legends.length) {
      legends.forEach((legend, legendIndex) => _createLegend(layer, legend, layerIndex, legendIndex, mapIndex));
    } else {
      _createLegend(layer, legends, layerIndex, 0, mapIndex);
    }
  }

  function _createLegend(layer, legend, layerIndex, legendIndex, mapIndex=0) {
    const element = document.querySelector(`#layer${layerIndex}_map${mapIndex}_legend${legendIndex}`);

    if (legend.prop) {
      const othersLabel = 'Others';   // TODO: i18n
      const prop = legend.prop;
      const dynamic = legend.dynamic;
      const order = legend.ascending ? 'ASC' : 'DESC';
      const variable = legend.variable;
      const config = { othersLabel, variable, order };
      const formatFunc = (value) => formatter(value, legend.format);
      const options = { format: formatFunc, config, dynamic };

      if (legend.type.startsWith('size-continuous')) {
        config.samples = 4;
      }

      AsBridge.VL.Legends.rampLegend(element, layer, prop, options);
    }
  }

  function SourceFactory() {
    const sourceTypes = { GeoJSON, Query, MVT };

    this.createSource = (layer) => {
      return sourceTypes[layer.type](layer);
    };
  }

  function GeoJSON(layer) {
    const options = JSON.parse(JSON.stringify(layer.options));
    const data = _decodeJSONData(layer.data, layer.encode_data);

    return new carto.source.GeoJSON(data, options);
  }

  function Query(layer) {
    const auth = {
      username: layer.credentials.username,
      apiKey: layer.credentials.api_key || 'default_public'
    };

    const config = {
      serverURL: layer.credentials.base_url || `https://${layer.credentials.username}.carto.com/`
    };

    return new carto.source.SQL(layer.data, auth, config);
  }

  function MVT(layer) {
    return new carto.source.MVT(layer.data.file, JSON.parse(layer.data.metadata));
  }

  function _decodeJSONData(data, encodeData) {
    try {
      if (encodeData) {
        const decodedJSON = pako.inflate(atob(data), { to: 'string' });
        return JSON.parse(decodedJSON);
      } else {
        return JSON.parse(data);
      }
    } catch(error) {
      throw new Error(`
      Error: &quot;${error}&quot;. CARTOframes is not able to parse your local data because it is too large.
      Please, disable the data compresion with encode_data=False in your Layer class.
    `);
    }
  }

  const factory = new SourceFactory();

  function initMapLayer(layer, layerIndex, numLayers, hasLegends, map, mapIndex) {
    const mapSource = factory.createSource(layer);
    const mapViz = new carto.Viz(layer.viz);
    const mapLayer = new carto.Layer(`layer${layerIndex}`, mapSource, mapViz);
    const mapLayerIndex = numLayers - layerIndex - 1;

    try {
      mapLayer._updateLayer.catch(displayError);
    } catch (e) {
      throw e;
    }

    mapLayer.addTo(map);

    setLayerLegend(layer, mapLayerIndex, mapLayer, mapIndex, hasLegends);
    setLayerWidgets(map, layer, mapLayer, mapLayerIndex, mapSource);

    return mapLayer;
  }

  function getInteractiveLayers(layers, mapLayers) {
    const interactiveLayers = [];
    const interactiveMapLayers = [];

    layers.forEach((layer, index) => {
      if (layer.interactivity) {
        interactiveLayers.push(layer);
        interactiveMapLayers.push(mapLayers[index]);
      }
    });

    return { interactiveLayers, interactiveMapLayers };
  }

  function setLayerLegend(layer, mapLayerIndex, mapLayer, mapIndex, hasLegends) {
    if (hasLegends && layer.legends) {
      createLegends(mapLayer, layer.legends, mapLayerIndex, mapIndex);
    }
  }

  function setLayerWidgets(map, layer, mapLayer, mapLayerIndex, mapSource) {
    if (layer.widgets.length) {
      initLayerWidgets(layer.widgets, mapLayerIndex);
      updateLayerWidgets(layer.widgets, mapLayer);
      bridgeLayerWidgets(map, mapLayer, mapSource, layer.widgets);
    }
  }

  function initLayerWidgets(widgets, mapLayerIndex) {
    widgets.forEach((widget, widgetIndex) => {
      const id = `layer${mapLayerIndex}_widget${widgetIndex}`;
      widget.id = id;
    });
  }

  function updateLayerWidgets(widgets, mapLayer) {
    mapLayer.on('updated', () => renderLayerWidgets(widgets, mapLayer));
  }

  function renderLayerWidgets(widgets, mapLayer) {
    const variables = mapLayer.viz.variables;

    widgets
      .filter((widget) => !widget.has_bridge)
      .forEach((widget) => {
        const name = widget.variable_name;
        const value = getWidgetValue(name, variables);
        renderWidget(widget, value);
      });
  }

  function getWidgetValue(name, variables) {
    return name && variables[name] ? variables[name].value : null;
  }

  function setReady(settings) {
    try {
      return settings.maps ? initMaps(settings.maps) : initMap(settings);
    } catch (e) {
      displayError(e);
    }
  }

  function initMaps(maps) {
    return maps.map((mapSettings, mapIndex) => {
      return initMap(mapSettings, mapIndex);
    });
  }

  function initMap(settings, mapIndex) {
    const basecolor = getBasecolorSettings(settings.basecolor);
    const basemapStyle =  BASEMAPS[settings.basemap] || settings.basemap || basecolor;
    const container = mapIndex !== undefined ? `map-${mapIndex}` : 'map';
    const map = createMap(container, basemapStyle, settings.bounds, settings.mapboxtoken);

    if (settings.show_info) {
      const id = mapIndex !== undefined ? `map-info-${mapIndex}` : 'map-info';
      updateViewport(id, map);
    }

    if (settings.camera) {
      map.flyTo(settings.camera);
    }

    return initLayers(map, settings, mapIndex);
  }

  function initLayers(map, settings, mapIndex) {
    const numLayers = settings.layers.length;
    const hasLegends = settings.has_legends;
    const isStatic = settings.is_static;
    const layers = settings.layers;
    const mapLayers = getMapLayers(
      layers,
      numLayers,
      hasLegends,
      map,
      mapIndex
    );

    if (settings.layer_selector) {
      addLayersSelector(layers.reverse(), mapLayers.reverse(), mapIndex);
    }

    setInteractiveLayers(map, layers, mapLayers);

    return waitForMapLayersLoad(isStatic, mapIndex, mapLayers);
  }

  function waitForMapLayersLoad(isStatic, mapIndex, mapLayers) {
    return new Promise((resolve) => {
      carto.on('loaded', mapLayers, onMapLayersLoaded.bind(
        this, isStatic, mapIndex, mapLayers, resolve)
      );
    });
  }

  function onMapLayersLoaded(isStatic, mapIndex, mapLayers, resolve) {
    if (isStatic) {
      saveImage(mapIndex);
    }

    resolve(mapLayers);
  }

  function getMapLayers(layers, numLayers, hasLegends, map, mapIndex) {
    return layers.map((layer, layerIndex) => {
      return initMapLayer(layer, layerIndex, numLayers, hasLegends, map, mapIndex);
    });
  }

  function setInteractiveLayers(map, layers, mapLayers) {
    const { interactiveLayers, interactiveMapLayers } = getInteractiveLayers(layers, mapLayers);

    if (interactiveLayers && interactiveLayers.length > 0) {
      setInteractivity(map, interactiveLayers, interactiveMapLayers);
    }
  }

  function addLayersSelector(layers, mapLayers, mapIndex) {
    const layerSelectorId = mapIndex !== undefined ? `#layer-selector-${mapIndex}` : '#layer-selector';
    const layerSelector$ = document.querySelector(layerSelectorId);
    const layersInfo = mapLayers.map((layer, index) => {
      return {
        title: layers[index].title || `Layer ${index}`,
        id: layer.id,
        checked: true
      };
    });

    const layerSelector = new AsBridge.VL.Layers(layerSelector$, carto, layersInfo, mapLayers);

    layerSelector.build();
  }

  function createMap(container, basemapStyle, bounds, accessToken) {
    const map = createMapboxGLMap(container, basemapStyle, accessToken);

    map.addControl(attributionControl);
    map.fitBounds(bounds, FIT_BOUNDS_SETTINGS);

    return map;
  }

  function createMapboxGLMap(container, style, accessToken) {
    if (accessToken) {
      mapboxgl.accessToken = accessToken;
    }

    return new mapboxgl.Map({
      container,
      style,
      zoom: 9,
      dragRotate: false,
      attributionControl: false
    });
  }

  function init(settings) {
    setReady(settings);
  }

  return init;

}());
</script>
<script>
  document
  .querySelector('as-responsive-content')
  .addEventListener('ready', () => {
    const basecolor = '';
    const basemap = 'Positron';
    const bounds = [[2.606594, 39.549467], [2.691243, 39.6013661]];
    const camera = null;
    const has_legends = 'true' === 'true';
    const is_static = 'None' === 'true';
    const layer_selector = 'False' === 'true';
    const layers = [{&quot;credentials&quot;: null, &quot;data&quot;: &quot;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&quot;, &quot;encode_data&quot;: true, &quot;has_legend_list&quot;: true, &quot;interactivity&quot;: [{&quot;attrs&quot;: {&quot;format&quot;: null, &quot;name&quot;: &quot;v2097c3&quot;, &quot;title&quot;: &quot;price&quot;}, &quot;event&quot;: &quot;hover&quot;}], &quot;legends&quot;: [{&quot;ascending&quot;: false, &quot;description&quot;: &quot;&quot;, &quot;dynamic&quot;: true, &quot;footer&quot;: &quot;&quot;, &quot;format&quot;: null, &quot;prop&quot;: &quot;color&quot;, &quot;title&quot;: &quot;price&quot;, &quot;type&quot;: &quot;color-bins&quot;, &quot;variable&quot;: null}], &quot;map_index&quot;: 0, &quot;options&quot;: {&quot;dateColumns&quot;: []}, &quot;source&quot;: &quot;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&quot;, &quot;title&quot;: null, &quot;type&quot;: &quot;GeoJSON&quot;, &quot;viz&quot;: &quot;@v2097c3: prop(\u0027price\u0027)\ncolor: opacity(ramp(globalQuantiles(prop(\u0027price\u0027), 5), purpor),1)\nfilter: 1\nstrokeColor: opacity(#222,ramp(linear(zoom(),0,18),[0,0.6]))\nstrokeWidth: ramp(linear(zoom(),0,18),[0,1])\nwidth: ramp(linear(zoom(),0,18),[2,10])\n&quot;, &quot;widgets&quot;: []}];
    const mapboxtoken = '';
    const show_info = 'None' === 'true';

    init({
      basecolor,
      basemap,
      bounds,
      camera,
      has_legends,
      is_static,
      layer_selector,
      layers,
      mapboxtoken,
      show_info
    });
});
</script>
</html>
">

</iframe>




```python
# Añadir una vez procesados los datos

from cartoframes.viz import category_widget, histogram_widget
Layer(gdf,
     widgets=[
         
         histogram_widget(
         'price',
          buckets=5,
          weight=3
         ),
         
         category_widget(
         'district',
         title='Distrito',
         description='Seleccionar distrito'
         )
     ]
    )
```




<iframe
  frameborder="0"
  style="
    border: 1px solid #cfcfcf;
    width: 100%;
    height: 632px;
    "
  srcDoc="
  <!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <title>None</title>
  <meta name=&quot;description&quot; content=&quot;None&quot;>
  <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
  <meta charset=&quot;UTF-8&quot;>
  <!-- Include CARTO VL JS -->
  <script src=&quot;https://libs.cartocdn.com/carto-vl/v1.4/carto-vl.min.js&quot;></script>
  <!-- Include Mapbox GL JS -->
  <script src=&quot;https://api.tiles.mapbox.com/mapbox-gl-js/v1.0.0/mapbox-gl.js&quot;></script>
  <!-- Include Mapbox GL CSS -->
  <link href=&quot;https://api.tiles.mapbox.com/mapbox-gl-js/v1.0.0/mapbox-gl.css&quot; rel=&quot;stylesheet&quot; />

  <!-- Include Airship -->
  <script nomodule=&quot;&quot; src=&quot;https://libs.cartocdn.com/airship-components/v2.3/airship.js&quot;></script>
  <script type=&quot;module&quot; src=&quot;https://libs.cartocdn.com/airship-components/v2.3/airship/airship.esm.js&quot;></script>
  <script src=&quot;https://libs.cartocdn.com/airship-bridge/v2.3/asbridge.min.js&quot;></script>
  <link href=&quot;https://libs.cartocdn.com/airship-style/v2.3/airship.min.css&quot; rel=&quot;stylesheet&quot;>
  <link href=&quot;https://libs.cartocdn.com/airship-icons/v2.3/icons.css&quot; rel=&quot;stylesheet&quot;>

  <link href=&quot;https://fonts.googleapis.com/css?family=Roboto&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;>

  <!-- External libraries -->

  <!-- pako -->
  <script src=&quot;https://libs.cartocdn.com/cartoframes/dependencies/pako_inflate.min.js&quot;></script>

  <!-- html2canvas -->



  <style>
  body {
    margin: 0;
    padding: 0;
  }

  aside.as-sidebar {
    min-width: 300px;
  }

  .map-image {
    display: none;
    max-width: 100%;
    height: auto;
  }

  as-layer-selector-slot .as-layer-selector-slot--wrapper .as-caption { // FIXME
    font-size: 14px;
    line-height: 14px;
  }
</style>
  <style>
  .map {
    position: absolute;
    height: 100%;
    width: 100%;
  }

  .map-info {
    position: absolute;
    bottom: 0;
    padding: 0 5px;
    background-color: rgba(255, 255, 255, 0.5);
    margin: 0;
    color: rgba(0, 0, 0, 0.75);
    font-size: 12px;
    width: auto;
    height: 18px;
    font-family: 'Open Sans';
  }

  .map-footer {
    background: #F2F6F9;
    font-family: Roboto;
    font-size: 12px;
    line-height: 24px;
    color: #162945;
    text-align: center;
    z-index: 2;
  }

  .map-footer a {
    text-decoration: none;
  }

  .map-footer a:hover {
    text-decoration: underline;
  }
</style>
    <style>
    #error-container {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: white;
      visibility: hidden;
      padding: 1em;
      font-family: &quot;Courier New&quot;, Courier, monospace;
      margin: 0 auto;
      font-size: 14px;
      overflow: auto;
      z-index: 1000;
      color: black;
    }

    .error-section {
      padding: 1em;
      border-radius: 5px;
      background-color: #fee;
    }

    #error-container #error-highlight {
      font-weight: bold;
      color: inherit;
    }

    #error-container #error-type {
      color: #008000;
    }

    #error-container #error-name {
      color: #ba2121;
    }

    #error-container #error-content {
      margin-top: 0.4em;
    }

    .error-details {
      margin-top: 1em;
    }

    #error-stacktrace {
      list-style: none;
    }
</style>
  <style>
    .popup-content {
      display: flex;
      flex-direction: column;
      padding: 8px;
    }

    .popup-name {
      font-size: 12px;
      font-weight: 400;
      line-height: 20px;
      margin-bottom: 4px;
    }

    .popup-value {
      font-size: 16px;
      font-weight: 600;
      line-height: 20px;
    }

    .popup-value:not(:last-of-type) {
      margin-bottom: 16px;
    }
</style>
  <style>
  as-widget-header .as-widget-header__header {
    margin-bottom: 8px;
    overflow-wrap: break-word;
  }

  as-widget-header .as-widget-header__subheader {
    margin-bottom: 12px;
  }

  as-category-widget {
    max-height: 250px;
  }
</style>
</head>

<body class=&quot;as-app-body as-app&quot;>
  <img id=&quot;map-image&quot; class=&quot;map-image&quot; alt='Static map image' />
  <as-responsive-content id=&quot;main-container&quot;>



<aside class=&quot;as-sidebar as-sidebar--right&quot; id=&quot;widgets&quot; data-name=&quot;Widgets&quot;>




          <div class=&quot;as-box&quot;>
            <section class=&quot;as-body&quot;>

      <div>
  <as-histogram-widget
    id=&quot;layer0_widget0&quot;
    description=&quot;&quot;
    heading=&quot;&quot;>
  </as-histogram-widget>

</div>

  </section>
          </div>

          <div class=&quot;as-box&quot;>
            <section class=&quot;as-body&quot;>

      <div>
  <as-category-widget
    id=&quot;layer0_widget1&quot;
    description=&quot;Seleccionar distrito&quot;
    heading=&quot;Distrito&quot;>
  </as-category-widget>

</div>

  </section>
          </div>



</aside>

    <main class=&quot;as-main&quot;>
      <div class=&quot;as-map-area&quot;>
        <div id=&quot;map&quot; class=&quot;map&quot;></div>


      </div> <!-- as-map-area -->
    </main> <!-- as-main -->
  </as-responsive-content>



  <div id=&quot;error-container&quot; class=&quot;error&quot;>
  <section class=&quot;error-section&quot;>
    <span class=&quot;errors&quot; id=&quot;error-name&quot;></span>:
    <section id=&quot;error-content&quot;>
      <span class=&quot;errors&quot; id=&quot;error-type&quot;></span>
      <span class=&quot;errors&quot; id=&quot;error-message&quot;></span>
    </section>
  </section>

  <details class=&quot;error-details&quot;>
    <summary>StackTrace</summary>
    <ul id=&quot;error-stacktrace&quot;></ul>
  </details>
</div>
</body>

<script>
  var init = (function () {
  'use strict';

  const BASEMAPS = {
    DarkMatter: carto.basemaps.darkmatter,
    Voyager: carto.basemaps.voyager,
    Positron: carto.basemaps.positron
  };

  const attributionControl = new mapboxgl.AttributionControl({
    compact: false
  });

  const FIT_BOUNDS_SETTINGS = { animate: false, padding: 50, maxZoom: 16 };

  /** From https://github.com/errwischt/stacktrace-parser/blob/master/src/stack-trace-parser.js */

  /**
   * This parses the different stack traces and puts them into one format
   * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
   */

  const UNKNOWN_FUNCTION = '<unknown>';
  const chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  const chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  const winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  const geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  const geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

  function parse(stackString) {
    const lines = stackString.split('\n');

    return lines.reduce((stack, line) => {
      const parseResult =
        parseChrome(line) ||
        parseWinjs(line) ||
        parseGecko(line);

      if (parseResult) {
        stack.push(parseResult);
      }

      return stack;
    }, []);
  }

  function parseChrome(line) {
    const parts = chromeRe.exec(line);

    if (!parts) {
      return null;
    }

    const isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

    const submatch = chromeEvalRe.exec(parts[2]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line/column number
      parts[2] = submatch[1]; // url
      parts[3] = submatch[2]; // line
      parts[4] = submatch[3]; // column
    }

    return {
      file: !isNative ? parts[2] : null,
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: isNative ? [parts[2]] : [],
      lineNumber: parts[3] ? +parts[3] : null,
      column: parts[4] ? +parts[4] : null,
    };
  }

  function parseWinjs(line) {
    const parts = winjsRe.exec(line);

    if (!parts) {
      return null;
    }

    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null,
    };
  }

  function parseGecko(line) {
    const parts = geckoRe.exec(line);

    if (!parts) {
      return null;
    }

    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;

    const submatch = geckoEvalRe.exec(parts[3]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line number
      parts[3] = submatch[1];
      parts[4] = submatch[2];
      parts[5] = null; // no column when eval
    }

    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: parts[2] ? parts[2].split(',') : [],
      lineNumber: parts[4] ? +parts[4] : null,
      column: parts[5] ? +parts[5] : null,
    };
  }

  function displayError(e) {
    const error$ = document.getElementById('error-container');
    const errors$ = error$.getElementsByClassName('errors');
    const stacktrace$ = document.getElementById('error-stacktrace');

    errors$[0].innerHTML = e.name;
    errors$[1].innerHTML = e.type;
    errors$[2].innerHTML = e.message.replace(e.type, '');

    error$.style.visibility = 'visible';

    const stack = parse(e.stack);
    const list = stack.map(item => {
      return `<li>
      at <span class=&quot;stacktrace-method&quot;>${item.methodName}:</span>
      (${item.file}:${item.lineNumber}:${item.column})
    </li>`;
    });

    stacktrace$.innerHTML = list.join('\n');
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns [&quot;123&quot;, 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(&quot;e&quot;)) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error(&quot;invalid format: &quot; + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? &quot; &quot; : specifier.fill + &quot;&quot;;
    this.align = specifier.align === undefined ? &quot;>&quot; : specifier.align + &quot;&quot;;
    this.sign = specifier.sign === undefined ? &quot;-&quot; : specifier.sign + &quot;&quot;;
    this.symbol = specifier.symbol === undefined ? &quot;&quot; : specifier.symbol + &quot;&quot;;
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? &quot;&quot; : specifier.type + &quot;&quot;;
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? &quot;0&quot; : &quot;&quot;)
        + (this.width === undefined ? &quot;&quot; : Math.max(1, this.width | 0))
        + (this.comma ? &quot;,&quot; : &quot;&quot;)
        + (this.precision === undefined ? &quot;&quot; : &quot;.&quot; + Math.max(0, this.precision | 0))
        + (this.trim ? &quot;~&quot; : &quot;&quot;)
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case &quot;.&quot;: i0 = i1 = i; break;
        case &quot;0&quot;: if (i0 === 0) i0 = i; i1 = i; break;
        default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + &quot;&quot;;
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join(&quot;0&quot;)
        : i > 0 ? coefficient.slice(0, i) + &quot;.&quot; + coefficient.slice(i)
        : &quot;0.&quot; + new Array(1 - i).join(&quot;0&quot;) + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + &quot;&quot;;
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? &quot;0.&quot; + new Array(-exponent).join(&quot;0&quot;) + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + &quot;.&quot; + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join(&quot;0&quot;);
  }

  var formatTypes = {
    &quot;%&quot;: function(x, p) { return (x * 100).toFixed(p); },
    &quot;b&quot;: function(x) { return Math.round(x).toString(2); },
    &quot;c&quot;: function(x) { return x + &quot;&quot;; },
    &quot;d&quot;: function(x) { return Math.round(x).toString(10); },
    &quot;e&quot;: function(x, p) { return x.toExponential(p); },
    &quot;f&quot;: function(x, p) { return x.toFixed(p); },
    &quot;g&quot;: function(x, p) { return x.toPrecision(p); },
    &quot;o&quot;: function(x) { return Math.round(x).toString(8); },
    &quot;p&quot;: function(x, p) { return formatRounded(x * 100, p); },
    &quot;r&quot;: formatRounded,
    &quot;s&quot;: formatPrefixAuto,
    &quot;X&quot;: function(x) { return Math.round(x).toString(16).toUpperCase(); },
    &quot;x&quot;: function(x) { return Math.round(x).toString(16); }
  };

  function identity(x) {
    return x;
  }

  var map = Array.prototype.map,
      prefixes = [&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;µ&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];

  function formatLocale(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + &quot;&quot;),
        currencyPrefix = locale.currency === undefined ? &quot;&quot; : locale.currency[0] + &quot;&quot;,
        currencySuffix = locale.currency === undefined ? &quot;&quot; : locale.currency[1] + &quot;&quot;,
        decimal = locale.decimal === undefined ? &quot;.&quot; : locale.decimal + &quot;&quot;,
        numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
        percent = locale.percent === undefined ? &quot;%&quot; : locale.percent + &quot;&quot;,
        minus = locale.minus === undefined ? &quot;-&quot; : locale.minus + &quot;&quot;,
        nan = locale.nan === undefined ? &quot;NaN&quot; : locale.nan + &quot;&quot;;

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The &quot;n&quot; type is an alias for &quot;,g&quot;.
      if (type === &quot;n&quot;) comma = true, type = &quot;g&quot;;

      // The &quot;&quot; type, and any invalid type, is an alias for &quot;.12~g&quot;.
      else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = &quot;g&quot;;

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === &quot;0&quot; && align === &quot;=&quot;)) zero = true, fill = &quot;0&quot;, align = &quot;=&quot;;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === &quot;$&quot; ? currencyPrefix : symbol === &quot;#&quot; && /[boxX]/.test(type) ? &quot;0&quot; + type.toLowerCase() : &quot;&quot;,
          suffix = symbol === &quot;$&quot; ? currencySuffix : /[%p]/.test(type) ? percent : &quot;&quot;;

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision === undefined ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === &quot;c&quot;) {
          valueSuffix = formatType(value) + valueSuffix;
          value = &quot;&quot;;
        } else {
          value = +value;

          // Determine the sign. -0 is not less than 0, but 1 / -0 is!
          var valueNegative = value < 0 || 1 / value < 0;

          // Perform the initial formatting.
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim(value);

          // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
          if (valueNegative && +value === 0 && sign !== &quot;+&quot;) valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === &quot;(&quot; ? sign : minus) : sign === &quot;-&quot; || sign === &quot;(&quot; ? &quot;&quot; : sign) + valuePrefix;
          valueSuffix = (type === &quot;s&quot; ? prefixes[8 + prefixExponent / 3] : &quot;&quot;) + valueSuffix + (valueNegative && sign === &quot;(&quot; ? &quot;)&quot; : &quot;&quot;);

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not &quot;0&quot;, grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : &quot;&quot;;

        // If the fill character is &quot;0&quot;, grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = &quot;&quot;;

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case &quot;<&quot;: value = valuePrefix + value + valueSuffix + padding; break;
          case &quot;=&quot;: value = valuePrefix + padding + value + valueSuffix; break;
          case &quot;^&quot;: value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + &quot;&quot;;
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = &quot;f&quot;, specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  var format;
  var formatPrefix;

  defaultLocale({
    decimal: &quot;.&quot;,
    thousands: &quot;,&quot;,
    grouping: [3],
    currency: [&quot;$&quot;, &quot;&quot;],
    minus: &quot;-&quot;
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  function formatter(value, specifier) {
    const formatFunc = specifier ? format(specifier) : formatValue;

    if (Array.isArray(value)) {
      const [first, second] = value;
      if (first === -Infinity) {
        return `< ${formatFunc(second)}`;
      }
      if (second === Infinity) {
        return `> ${formatFunc(first)}`;
      }
      return `${formatFunc(first)} - ${formatFunc(second)}`;
    }
    return formatFunc(value);
  }

  function formatValue(value) {
    if (typeof value === 'number') {
      return formatNumber(value);
    }
    return value;
  }

  function formatNumber(value) {
    if (!Number.isInteger(value)) {
      return value.toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 3
      });
    }
    return value.toLocaleString();
  }

  function updateViewport(id, map) {
    function updateMapInfo() {
      const mapInfo$ = document.getElementById(id);
      const center = map.getCenter();
      const lat = center.lat.toFixed(6);
      const lng = center.lng.toFixed(6);
      const zoom = map.getZoom().toFixed(2);

      mapInfo$.innerText = `viewport={'zoom': ${zoom}, 'lat': ${lat}, 'lng': ${lng}}`;
    }

    updateMapInfo();

    map.on('zoom', updateMapInfo);
    map.on('move', updateMapInfo);
  }

  function getBasecolorSettings(basecolor) {
    return {
      'version': 8,
      'sources': {},
      'layers': [{
          'id': 'background',
          'type': 'background',
          'paint': {
              'background-color': basecolor
          }
      }]
    };
  }

  function getImageElement(mapIndex) {
    const id = mapIndex !== undefined ? `map-image-${mapIndex}` : 'map-image';
    return document.getElementById(id);
  }

  function getContainerElement(mapIndex) {
    const id = mapIndex !== undefined ? `main-container-${mapIndex}` : 'main-container';
    return document.getElementById(id);
  }

  function saveImage(mapIndex) {
    const img = getImageElement(mapIndex);
    const container = getContainerElement(mapIndex);

    html2canvas(container)
      .then((canvas) => setMapImage(canvas, img, container));
  }

  function setMapImage(canvas, img, container) {
    const src = canvas.toDataURL();
    img.setAttribute('src', src);
    img.style.display = 'block';
    container.style.display = 'none';
  }

  function resetPopupClick(interactivity) {
    interactivity.off('featureClick');
  }

  function resetPopupHover(interactivity) {
    interactivity.off('featureHover');
  }

  function setPopupsClick(map, clickPopup, hoverPopup, interactivity, attrs) {
    interactivity.on('featureClick', (event) => {
      updatePopup(map, clickPopup, event, attrs);
      hoverPopup.remove();
    });
  }

  function setPopupsHover(map, hoverPopup, interactivity, attrs) {
    interactivity.on('featureHover', (event) => {
      updatePopup(map, hoverPopup, event, attrs);
    });
  }

  function updatePopup(map, popup, event, attrs) {
    if (event.features.length > 0) {
      let popupHTML = '';
      const layerIDs = [];

      for (const feature of event.features) {
        if (layerIDs.includes(feature.layerId)) {
          continue;
        }
        // Track layers to add only one feature per layer
        layerIDs.push(feature.layerId);

        for (const item of attrs) {
          const variable = feature.variables[item.name];
          if (variable) {
            let value = variable.value;
            value = formatter(value, item.format);

            popupHTML = `
            <span class=&quot;popup-name&quot;>${item.title}</span>
            <span class=&quot;popup-value&quot;>${value}</span>
          ` + popupHTML;
          }
        }
      }

      if (popupHTML) {
        popup
            .setLngLat([event.coordinates.lng, event.coordinates.lat])
            .setHTML(`<div class=&quot;popup-content&quot;>${popupHTML}</div>`);

        if (!popup.isOpen()) {
          popup.addTo(map);
        }
      } else {
        popup.remove();
      }
    } else {
      popup.remove();
    }
  }

  function setInteractivity(map, interactiveLayers, interactiveMapLayers) {
    const interactivity = new carto.Interactivity(interactiveMapLayers);

    const clickPopup = new mapboxgl.Popup({
      closeButton: true,
      closeOnClick: false
    });

    const hoverPopup = new mapboxgl.Popup({
      closeButton: false,
      closeOnClick: false
    });

    const { clickAttrs, hoverAttrs } = _setInteractivityAttrs(interactiveLayers);

    resetPopupClick(map);
    resetPopupHover(map);

    if (clickAttrs.length > 0) {
      setPopupsClick(map, clickPopup, hoverPopup, interactivity, clickAttrs);
    }

    if (hoverAttrs.length > 0) {
      setPopupsHover(map, hoverPopup, interactivity, hoverAttrs);
    }
  }

  function _setInteractivityAttrs(interactiveLayers) {
    let clickAttrs = [];
    let hoverAttrs = [];

    interactiveLayers.forEach((interactiveLayer) => {
      interactiveLayer.interactivity.forEach((interactivityDef) => {
        if (interactivityDef.event === 'click') {
          clickAttrs = clickAttrs.concat(interactivityDef.attrs);
        } else if (interactivityDef.event === 'hover') {
          hoverAttrs = hoverAttrs.concat(interactivityDef.attrs);
        }
      });
    });

    return { clickAttrs, hoverAttrs };
  }

  function renderWidget(widget, value) {
    widget.element = widget.element || document.querySelector(`#${widget.id}-value`);

    if (value && widget.element) {
      widget.element.innerText = typeof value === 'number' ? formatter(value, widget.options.format) : value;
    }
  }

  function renderBridge(bridge, widget, mapLayer) {
    widget.element = widget.element || document.querySelector(`#${widget.id}`);

    switch (widget.type) {
      case 'histogram':
        const type = _getWidgetType(mapLayer, widget.value, widget.prop);
        const histogram = type === 'category' ? 'categoricalHistogram' : 'numericalHistogram';
        bridge[histogram](widget.element, widget.value, widget.options);
        break;
      case 'category':
        bridge.category(widget.element, widget.value, widget.options);
        break;
      case 'animation':
        widget.options.propertyName = widget.prop;
        bridge.animationControls(widget.element, widget.value, widget.options);
        break;
      case 'time-series':
        widget.options.propertyName = widget.prop;
        bridge.timeSeries(widget.element, widget.value, widget.options);
        break;
    }
  }

  function bridgeLayerWidgets(map, mapLayer, mapSource, widgets) {
    const bridge = new AsBridge.VL.Bridge({
      carto: carto,
      layer: mapLayer,
      source: mapSource,
      map: map
    });

    widgets
      .filter((widget) => widget.has_bridge)
      .forEach((widget) => renderBridge(bridge, widget, mapLayer));

    bridge.build();
  }

  function _getWidgetType(layer, property, value) {
    return layer.metadata && layer.metadata.properties[value] ?
      layer.metadata.properties[value].type
      : _getWidgetPropertyType(layer, property);
  }

  function _getWidgetPropertyType(layer, property) {
    return layer.metadata && layer.metadata.properties[property] ?
      layer.metadata.properties[property].type
      : null;
  }

  function createLegends(layer, legends, layerIndex, mapIndex=0) {
    if (legends.length) {
      legends.forEach((legend, legendIndex) => _createLegend(layer, legend, layerIndex, legendIndex, mapIndex));
    } else {
      _createLegend(layer, legends, layerIndex, 0, mapIndex);
    }
  }

  function _createLegend(layer, legend, layerIndex, legendIndex, mapIndex=0) {
    const element = document.querySelector(`#layer${layerIndex}_map${mapIndex}_legend${legendIndex}`);

    if (legend.prop) {
      const othersLabel = 'Others';   // TODO: i18n
      const prop = legend.prop;
      const dynamic = legend.dynamic;
      const order = legend.ascending ? 'ASC' : 'DESC';
      const variable = legend.variable;
      const config = { othersLabel, variable, order };
      const formatFunc = (value) => formatter(value, legend.format);
      const options = { format: formatFunc, config, dynamic };

      if (legend.type.startsWith('size-continuous')) {
        config.samples = 4;
      }

      AsBridge.VL.Legends.rampLegend(element, layer, prop, options);
    }
  }

  function SourceFactory() {
    const sourceTypes = { GeoJSON, Query, MVT };

    this.createSource = (layer) => {
      return sourceTypes[layer.type](layer);
    };
  }

  function GeoJSON(layer) {
    const options = JSON.parse(JSON.stringify(layer.options));
    const data = _decodeJSONData(layer.data, layer.encode_data);

    return new carto.source.GeoJSON(data, options);
  }

  function Query(layer) {
    const auth = {
      username: layer.credentials.username,
      apiKey: layer.credentials.api_key || 'default_public'
    };

    const config = {
      serverURL: layer.credentials.base_url || `https://${layer.credentials.username}.carto.com/`
    };

    return new carto.source.SQL(layer.data, auth, config);
  }

  function MVT(layer) {
    return new carto.source.MVT(layer.data.file, JSON.parse(layer.data.metadata));
  }

  function _decodeJSONData(data, encodeData) {
    try {
      if (encodeData) {
        const decodedJSON = pako.inflate(atob(data), { to: 'string' });
        return JSON.parse(decodedJSON);
      } else {
        return JSON.parse(data);
      }
    } catch(error) {
      throw new Error(`
      Error: &quot;${error}&quot;. CARTOframes is not able to parse your local data because it is too large.
      Please, disable the data compresion with encode_data=False in your Layer class.
    `);
    }
  }

  const factory = new SourceFactory();

  function initMapLayer(layer, layerIndex, numLayers, hasLegends, map, mapIndex) {
    const mapSource = factory.createSource(layer);
    const mapViz = new carto.Viz(layer.viz);
    const mapLayer = new carto.Layer(`layer${layerIndex}`, mapSource, mapViz);
    const mapLayerIndex = numLayers - layerIndex - 1;

    try {
      mapLayer._updateLayer.catch(displayError);
    } catch (e) {
      throw e;
    }

    mapLayer.addTo(map);

    setLayerLegend(layer, mapLayerIndex, mapLayer, mapIndex, hasLegends);
    setLayerWidgets(map, layer, mapLayer, mapLayerIndex, mapSource);

    return mapLayer;
  }

  function getInteractiveLayers(layers, mapLayers) {
    const interactiveLayers = [];
    const interactiveMapLayers = [];

    layers.forEach((layer, index) => {
      if (layer.interactivity) {
        interactiveLayers.push(layer);
        interactiveMapLayers.push(mapLayers[index]);
      }
    });

    return { interactiveLayers, interactiveMapLayers };
  }

  function setLayerLegend(layer, mapLayerIndex, mapLayer, mapIndex, hasLegends) {
    if (hasLegends && layer.legends) {
      createLegends(mapLayer, layer.legends, mapLayerIndex, mapIndex);
    }
  }

  function setLayerWidgets(map, layer, mapLayer, mapLayerIndex, mapSource) {
    if (layer.widgets.length) {
      initLayerWidgets(layer.widgets, mapLayerIndex);
      updateLayerWidgets(layer.widgets, mapLayer);
      bridgeLayerWidgets(map, mapLayer, mapSource, layer.widgets);
    }
  }

  function initLayerWidgets(widgets, mapLayerIndex) {
    widgets.forEach((widget, widgetIndex) => {
      const id = `layer${mapLayerIndex}_widget${widgetIndex}`;
      widget.id = id;
    });
  }

  function updateLayerWidgets(widgets, mapLayer) {
    mapLayer.on('updated', () => renderLayerWidgets(widgets, mapLayer));
  }

  function renderLayerWidgets(widgets, mapLayer) {
    const variables = mapLayer.viz.variables;

    widgets
      .filter((widget) => !widget.has_bridge)
      .forEach((widget) => {
        const name = widget.variable_name;
        const value = getWidgetValue(name, variables);
        renderWidget(widget, value);
      });
  }

  function getWidgetValue(name, variables) {
    return name && variables[name] ? variables[name].value : null;
  }

  function setReady(settings) {
    try {
      return settings.maps ? initMaps(settings.maps) : initMap(settings);
    } catch (e) {
      displayError(e);
    }
  }

  function initMaps(maps) {
    return maps.map((mapSettings, mapIndex) => {
      return initMap(mapSettings, mapIndex);
    });
  }

  function initMap(settings, mapIndex) {
    const basecolor = getBasecolorSettings(settings.basecolor);
    const basemapStyle =  BASEMAPS[settings.basemap] || settings.basemap || basecolor;
    const container = mapIndex !== undefined ? `map-${mapIndex}` : 'map';
    const map = createMap(container, basemapStyle, settings.bounds, settings.mapboxtoken);

    if (settings.show_info) {
      const id = mapIndex !== undefined ? `map-info-${mapIndex}` : 'map-info';
      updateViewport(id, map);
    }

    if (settings.camera) {
      map.flyTo(settings.camera);
    }

    return initLayers(map, settings, mapIndex);
  }

  function initLayers(map, settings, mapIndex) {
    const numLayers = settings.layers.length;
    const hasLegends = settings.has_legends;
    const isStatic = settings.is_static;
    const layers = settings.layers;
    const mapLayers = getMapLayers(
      layers,
      numLayers,
      hasLegends,
      map,
      mapIndex
    );

    if (settings.layer_selector) {
      addLayersSelector(layers.reverse(), mapLayers.reverse(), mapIndex);
    }

    setInteractiveLayers(map, layers, mapLayers);

    return waitForMapLayersLoad(isStatic, mapIndex, mapLayers);
  }

  function waitForMapLayersLoad(isStatic, mapIndex, mapLayers) {
    return new Promise((resolve) => {
      carto.on('loaded', mapLayers, onMapLayersLoaded.bind(
        this, isStatic, mapIndex, mapLayers, resolve)
      );
    });
  }

  function onMapLayersLoaded(isStatic, mapIndex, mapLayers, resolve) {
    if (isStatic) {
      saveImage(mapIndex);
    }

    resolve(mapLayers);
  }

  function getMapLayers(layers, numLayers, hasLegends, map, mapIndex) {
    return layers.map((layer, layerIndex) => {
      return initMapLayer(layer, layerIndex, numLayers, hasLegends, map, mapIndex);
    });
  }

  function setInteractiveLayers(map, layers, mapLayers) {
    const { interactiveLayers, interactiveMapLayers } = getInteractiveLayers(layers, mapLayers);

    if (interactiveLayers && interactiveLayers.length > 0) {
      setInteractivity(map, interactiveLayers, interactiveMapLayers);
    }
  }

  function addLayersSelector(layers, mapLayers, mapIndex) {
    const layerSelectorId = mapIndex !== undefined ? `#layer-selector-${mapIndex}` : '#layer-selector';
    const layerSelector$ = document.querySelector(layerSelectorId);
    const layersInfo = mapLayers.map((layer, index) => {
      return {
        title: layers[index].title || `Layer ${index}`,
        id: layer.id,
        checked: true
      };
    });

    const layerSelector = new AsBridge.VL.Layers(layerSelector$, carto, layersInfo, mapLayers);

    layerSelector.build();
  }

  function createMap(container, basemapStyle, bounds, accessToken) {
    const map = createMapboxGLMap(container, basemapStyle, accessToken);

    map.addControl(attributionControl);
    map.fitBounds(bounds, FIT_BOUNDS_SETTINGS);

    return map;
  }

  function createMapboxGLMap(container, style, accessToken) {
    if (accessToken) {
      mapboxgl.accessToken = accessToken;
    }

    return new mapboxgl.Map({
      container,
      style,
      zoom: 9,
      dragRotate: false,
      attributionControl: false
    });
  }

  function init(settings) {
    setReady(settings);
  }

  return init;

}());
</script>
<script>
  document
  .querySelector('as-responsive-content')
  .addEventListener('ready', () => {
    const basecolor = '';
    const basemap = 'Positron';
    const bounds = [[2.606594, 39.549467], [2.691243, 39.6013661]];
    const camera = null;
    const has_legends = 'False' === 'true';
    const is_static = 'None' === 'true';
    const layer_selector = 'False' === 'true';
    const layers = [{&quot;credentials&quot;: null, &quot;data&quot;: &quot;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&quot;, &quot;encode_data&quot;: true, &quot;has_legend_list&quot;: true, &quot;interactivity&quot;: [], &quot;legends&quot;: [], &quot;map_index&quot;: 0, &quot;options&quot;: {&quot;dateColumns&quot;: []}, &quot;source&quot;: &quot;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&quot;, &quot;title&quot;: null, &quot;type&quot;: &quot;GeoJSON&quot;, &quot;viz&quot;: &quot;@v2097c3: prop(\u0027price\u0027)\n@vdfbbe7: prop(\u0027district\u0027)\ncolor: hex(\&quot;#EE4D5A\&quot;)\nstrokeColor: opacity(#222,ramp(linear(zoom(),0,18),[0,0.6]))\nstrokeWidth: ramp(linear(zoom(),0,18),[0,1])\nwidth: ramp(linear(zoom(),0,18),[2,10])\n&quot;, &quot;widgets&quot;: [{&quot;description&quot;: &quot;&quot;, &quot;footer&quot;: &quot;&quot;, &quot;has_bridge&quot;: true, &quot;options&quot;: {&quot;autoplay&quot;: true, &quot;buckets&quot;: 5, &quot;format&quot;: null, &quot;readOnly&quot;: false, &quot;weight&quot;: 3}, &quot;prop&quot;: &quot;&quot;, &quot;title&quot;: &quot;&quot;, &quot;type&quot;: &quot;histogram&quot;, &quot;value&quot;: &quot;price&quot;, &quot;variable_name&quot;: &quot;v2097c3&quot;}, {&quot;description&quot;: &quot;Seleccionar distrito&quot;, &quot;footer&quot;: &quot;&quot;, &quot;has_bridge&quot;: true, &quot;options&quot;: {&quot;autoplay&quot;: true, &quot;buckets&quot;: 20, &quot;format&quot;: null, &quot;readOnly&quot;: false, &quot;weight&quot;: 1}, &quot;prop&quot;: &quot;&quot;, &quot;title&quot;: &quot;Distrito&quot;, &quot;type&quot;: &quot;category&quot;, &quot;value&quot;: &quot;district&quot;, &quot;variable_name&quot;: &quot;vdfbbe7&quot;}]}];
    const mapboxtoken = '';
    const show_info = 'None' === 'true';

    init({
      basecolor,
      basemap,
      bounds,
      camera,
      has_legends,
      is_static,
      layer_selector,
      layers,
      mapboxtoken,
      show_info
    });
});
</script>
</html>
">

</iframe>


